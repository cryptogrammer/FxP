Utkarsh Garg (utkarsh6@gatech.edu), Tanay Ponkshe (tponkshe@gatech.edu)

CS 3251-B, Networking 1, 4/14/2014, Programming Assignment 2

==================================================================================

Description of files provided:

NetEmu.py - the provided net emulator file
client.py - the protocol’s client side implementation
server.py - the protocol’s server side implementation
FxA-client.py - FxA’s client implementation
FxA-server.py - FxA’s server implementation
—-NOT USED AS A SEPARATE FILE— fec.py - file containing forward error correction
—-NOT USED AS A SEPARATE FILE— crypto.py - file containing the rsa encryption code
—-NOT USED AS A SEPARATE FILE— checksum.py - implementation of the checksum
Sample.txt - contains sample command line output for a GET and a POST command
RxP Design Report.pdf - the design report

Additionally, 3 text files have been provided that were used for testing. Two of them (clientReceivedFile.txt and serverReceivedFile.txt) are generated by the program, and the test.txt file is what was being passed as input.


==================================================================================


Instructions for Running File Transfer FxP:

Note: To run the files, you will need to have the python rss module installed on your machine. You can either do ‘pip install rsa’ or ‘python -m pip  install rsa’ (if you have multiple versions of python), or download the package from https://pypi.python.org/pypi/rsa.


FxA Server:

Command-line: python FxA-server.py [X] [A] [P] 

The command-line arguments are:
X: the port number at which the FxA-server’s UDP socket should bind to (odd number) 
A: the IP address of NetEmu
P: the UDP port number of NetEmu 


FxA Client:

Command-line: python FxA-client.py [X] [A] [P] 

The command-line arguments are: 

X: the port number at which the FxA-client’s UDP socket should bind to (even number). Please remember that this port number should be equal to the server’s port number minus 1. 
A: the IP address of NetEmu
P: the UDP port number of NetEmu 

Once the client is running, the following can be called by typing into the terminal:

connect - The FxA-client connects to the FxA-server (running at the same IP host). 

get [F] - The FxA-client downloads file F from the server (if F exists in the same directory with the FxA-server program). The received file is stored in the same directory as the client program, under the name ‘clientReceivedFile.txt’.

post [F] - The FxA-client uploads file F to the server (if F exists in the same directory with the FxA-client program). The uploaded file is stored in the same directory as the server program, under the name ‘serverReceivedFile.txt’.

disconnect - The FxA-client terminates gracefully from the FxA-server.

=====================================================================================

Updated protocol and API description with sufficient detail:

We implemented a half-duplex RxP protocol that is similar to TCP in some aspects. On "connect" the client initiates a connection with the server by sending a SYN request. The server responds with a SYN-ACK and also passes its RSA public key. On receiving this SYN_ACK, the client generates its own RSA public+private keys and sends a SYN-ACK packet to the server with its public key. The server accepts this key and sends a "final handshake ACK" to the client. This completes a 4-way handshake between the client and server in order to "Establish" the connection.
At this stage, the client has 3 options:

1) post [filename] : This allows the client to post file "filename" to the server
For this command, the client sends a special "POST" request packet to the server which is waiting fot a client command. The server notices the "POST" datafield in the message and sends an ACK confirming that it is ready to receive the file. The client initializes its Send Buffer with Default_Window_Size number of packets and sends them to the server without waiting for individual ACKS. if an ACK is received during this transmission, the state of the packet in the window is updated as being "ACKED". This is continued until an ACK is received for the "First Unacked Packet" or until there are Default_Window_Size number of UNACKED packets "inflight". When an ACK is received for the "First Unacked Packet" in the window, the window "slides" until it encounters the next unacked packet and the process is repeated. When the Default_Window_Size number of UNACKED packets are in flight, the client waits until it receives an ACK for the First Unacked Packet. Also, during the POST special request, the client tells the server the number of unique packets it should expect. THis helps the server to decide when to stop listening for more file components. When this condition is reached, the server combines the received packets and creates a file. This completes the file transfer. The client goes back to the ready state "Established"

2) get [filename] : This allows the client to request a file with name "filename" from the server.
For this command, the client send sends a special "GET" request packet to the server tellinng it what file it wants. The server notices this "GET" datafield from the packet and sends back an ACK confirming that it is ready to send the file. It also tells the client the number of unique packets it should expect for the given file. The server follows a similar transmission and retransmission protocol similar to client's POST. Once the client receives the expected number of unique packets in its receive buffer, it combines the received packets and creates a file. This completes the GET request where the Client recieved the complete file. From here, the client goes into the ready state "Established"

3) disconnect: disconnects client and server connection.
Once the Client is done with the GET or POST command and has successfully completed the file transfer, it now has an option to call DISCONNECT. When this command is called, a 4-way handshake is initiated by the client to close the existing connection with the server. The client sends a FIN I request to the server. The server recognizes this FIN packet and sends a FIN-ACK packet to the cleint as a response. Now, the server sends its own FIN J request to the client telling that it is ready to disconnect. Upon receiving this FIN J from the server, the client sends the Final ACK after which it goes into TIMED WAIT state. The server receives the final ACK and closes the connection and exits. The client waits until a specified timeout and listens to the server. once this timeout expires, the cliend too close the connection. The client listens to the server during the timed wait in order to ensure that its FINAL ACK reached successfully. If the Final ACK gets lost, the server will resend its FIN J and the process will repeat until the disconnection is successful.


=====================================================================================

Known Limitations/Bugs.

1. Vulnerability of the code: If any command is formatted in a different way, the program will throw an exception and crash. The disconnected command is implemented in such a way that if anything is typed other than disconnect, the connection is terminated anyway i.e. after the connect stage, if any incorrect command is typed, the connection will terminate and both the client and the server will shut down.

2. In a single connection, multiple simultaneous GET/POST requests are not supported. After the completion of a GET/POST, the only command option is to disconnect.

=====================================================================================